package minijava.syntax;

import minijava.ast.*;
import static minijava.ast.MJ.*;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.function.Consumer;
import frontend.SyntaxError;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;


class MiniJavaParser;
   
// Parser code to change the way the parser reports errors (include
// line and column number of the error). 
parser code {:
    
    private Consumer<SyntaxError> onError;

    public void onError(Consumer<SyntaxError> onError) {
        this.onError = onError;
    }
    

    @Override
    public void syntax_error(Symbol info) {

        List<Integer> expectedTokens = expected_token_ids();
        
        int line, column;
        StringBuilder message = new StringBuilder("Unexpected token ");
        if (info instanceof ComplexSymbol) {
            ComplexSymbol s = (ComplexSymbol) info;
            line = s.getLeft().getLine();
            column = s.getLeft().getColumn();
            
            message.append(s.getName());
            
            if (s.value != null) {
                message.append("(");
                message.append(s.value);
                message.append(")");
            }
        } else {
            line = cur_token.left;
            column = cur_token.right;
        }
        
        if (!expectedTokens.isEmpty()) {
            message.append(", expected one of the following: ");
            boolean first = true;
            for (int expected : expectedTokens){
                if (!first) {
                    message.append(", ");
                }
                message.append(symbl_name_from_id(expected));
                first = false;
            }
        }
        
        
        SyntaxError err = new SyntaxError(message.toString(), line, column);
        if (onError == null) {
            System.err.println(err);
        } else {
            onError.accept(err);
        }
    }

    @Override
    public void report_fatal_error(String message, Object info) {
        // ignore
    }
    
:};
   

   
/* ------------Declaration of Terminals and Non Terminals Section----------- */

terminal INVALID_TOKEN;

// Java keywords:
terminal ABSTRACT,  CONTINUE,   FOR,          NEW,         SWITCH,
         ASSERT,    DEFAULT,    IF,           PACKAGE,     SYNCHRONIZED,
         BOOLEAN,   DO,         GOTO,         PRIVATE,     THIS,
         BREAK,     DOUBLE,     IMPLEMENTS,   PROTECTED,   THROW,
         BYTE,      ELSE,       IMPORT,       PUBLIC,      THROWS,
         CASE,      ENUM,       INSTANCEOF,   RETURN,      TRANSIENT,
         CATCH,     EXTENDS,    INT,          SHORT,       TRY,
         CHAR,      FINAL,      INTERFACE,    STATIC,      VOID,
         CLASS,     FINALLY,    LONG,         STRICTFP,    VOLATILE,
         CONST,     FLOAT,      NATIVE,       SUPER,       WHILE;

// additional keywords:
terminal MAIN, STRING, LENGTH, SYSTEM, OUT, PRINTLN;

// symbols:
terminal LBRACE, RBRACE, // { }
         LBRACKET, RBRACKET, // [ ]
         LPAREN, RPAREN, // ()
         DOT, SEMI, COMMA, EQ, NEG, AND, PLUS, MINUS, TIMES, DIV, LESS, EQUALS;

// literals:
terminal TRUE, FALSE, NULL;

terminal String   NUMBER, ID;
   
// Non terminals used in the grammar section.  
non terminal MJProgram program;
non terminal MJMainClass mainclass;
non terminal MJClassDecl classdecl;
<<<<<<< Updated upstream
non terminal MJMemberDecl memberdecl;
non terminal MJStatement statement;
non terminal MJBlock block;
non terminal MJVarDecl vardecl;
non terminal MJMethodDecl methodecl;
non terminal MJVarDeclList vardeclist;
=======

//Monireh
non terminal MJType type;
//Rama
non terminal MJOperator op;
non terminal MJExpr expr;



/* ----------------------------Grammar Section-------------------- */


 program ::=
         mainclass:mc classdecl:cd
         {: RESULT = new MJProgram(mc, cd); :}
        ;
    mc ::=
        CLASS ID LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID RPAREN block:b RBRACE
        {:id = new MJTypeClass(name);
         RESULT = new MJMainClass(id,b); :}
        ;

    cd ::=
        CLASS ID LBRACE memberdecl:md RBRACE
        {:id = new MJTypeClass(name);
        RESULT = new MJClassDecl(id,md); :}
        | CLASS ID EXTENDS ID LBRACE memberdecl:md RBRACE
        {:id = new MJTypeClass(name);
         RESULT = new MJClassDecl(id, md); :}

    ;

    md ::= vardecl:vd
    {: RESULT=new MJMemberDecl(vd); :}
    |
    methodecl:mtd
    {: RESULT=new MJMemberDecl(mtd); :}
    ;

    vd ::= type:t ID SEMI
    {:id = new MJTypeClass(name);
    RESULT = new MJVarDecl(t,id); :}
    ;

    mtd::= type:t ID LBRACE vardeclist:vdl RBRACE block:b
    {:id = new MJTypeClass(name);
    RESULT= new MJMethodDecl(t,id,vdl,b);:}
    ;

    vdl ::= type:t ID vardeclist:vdlrest
    {:id = new MJTypeClass(name);
    RESULT =  new MJVarDeclList(t,id,vdlrest);:}
    ;

    vdlrest ::= COMMA type:t ID
    {:id = new MJTypeClass(name);
    RESULT = new MJVarDeclList(t,id); :}
    ;


  MethodDecl → Type id ( ParamList ?
 ) Block
 ParamList → Type id ParamRest*
 ParamRest → , Type id
  INT  LBRACKET RBRACKET| BOOLEAN |INT| ID
   {: RESULT = new MJMainType(); :}
 Block → { BlockStatement* }
 BlockStatement → Statement| Type id ;
 Statement → Block | if ( Exp ) Statement else Statement| while ( Exp ) Statement
 | return Exp;| System . out . println ( Exp ) ;| Exp; | Exp= Exp;
 Exp → Exp op Exp| ! Exp | - Exp  | Exp[ Exp ]| Exp . length
 | Exp . id | Exp . id ( ExpList ? ) | true | false | id | hinteger literali
 | this| null| new int [ Exp ]  | new id ( ) | ( Exp )
   {: RESULT =MJExpr(); :}
  Exp ExpRest*
   {: RESULT = MJExprList(); :}

 ExpRest → , Exp
 id → hidentifieri

  AND | PLUS | MINUS | TIMES | DIV | LESS | EQUALS
   {: RESULT = MJOperator(); :}
 ;
//Monireh start
 type ::=
        INT LBRACKET RBRACKET  {: RESULT = new MJTypeIntArray(); :}
        | BOOLEAN              {: RESULT = new MJTypeBool(); :}
        | INT                  {: RESULT = new MJTypeInt(); :}
        | ID:name              {: RESULT = new MJTypeClass(name); :}
//End of Type
expr ::=       expr:e1 op expr:e2
			   {: RESULT = new MJOperator(); :}
			   |
			   NEG expr:e1
			   {: RESULT = newMJNegate(); :}
			   |

			   TRUE
			   {: RESULT = new MJTypeBool(); :}
			   |
			   FALSE
			   {: RESULT = MJTypeBool(); :}
			   |
			   ID:id
			   {: RESULT = new MJTypeClass(id); : :}
			   |
			   THIS:t
			   {: RESULT = new MJTypeClass(); :}
			   |
			   NULL:n
               {: RESULT = new MJTypeClass(); :}
               |
			   NEW INT LBRACKET expr:e1 RBRACKET
			   {: RESULT = new NewArrayLength(e1); :}
			   |



ExpRest ::  COMMA  expr e
ID ::
          less
op::
          AND {: RESULT = MJAnd(); :}
          | PLUS {: RESULT = MJPlus(); :}
           | MINUS {: RESULT = MJMinus(); :}
           | TIMES {: RESULT = MJTimes(); :}
           | DIV {: RESULT = MJDiv(); :}
           | LESS {: RESULT = MJLess(); :}
           | EQUALS {: RESULT = MJEquals(); :}






