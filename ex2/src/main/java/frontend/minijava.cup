package minijava.syntax;

import minijava.ast.*;
import static minijava.ast.MJ.*;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.function.Consumer;
import frontend.SyntaxError;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;


class MiniJavaParser;
   
// Parser code to change the way the parser reports errors (include
// line and column number of the error). 
parser code {:
    
    private Consumer<SyntaxError> onError;

    public void onError(Consumer<SyntaxError> onError) {
        this.onError = onError;
    }
    

    @Override
    public void syntax_error(Symbol info) {

        List<Integer> expectedTokens = expected_token_ids();
        
        int line, column;
        StringBuilder message = new StringBuilder("Unexpected token ");
        if (info instanceof ComplexSymbol) {
            ComplexSymbol s = (ComplexSymbol) info;
            line = s.getLeft().getLine();
            column = s.getLeft().getColumn();
            
            message.append(s.getName());
            
            if (s.value != null) {
                message.append("(");
                message.append(s.value);
                message.append(")");
            }
        } else {
            line = cur_token.left;
            column = cur_token.right;
        }
        
        if (!expectedTokens.isEmpty()) {
            message.append(", expected one of the following: ");
            boolean first = true;
            for (int expected : expectedTokens){
                if (!first) {
                    message.append(", ");
                }
                message.append(symbl_name_from_id(expected));
                first = false;
            }
        }
        
        
        SyntaxError err = new SyntaxError(message.toString(), line, column);
        if (onError == null) {
            System.err.println(err);
        } else {
            onError.accept(err);
        }
    }

    @Override
    public void report_fatal_error(String message, Object info) {
        // ignore
    }
    
:};
   

   
/* ------------Declaration of Terminals and Non Terminals Section----------- */

terminal INVALID_TOKEN;

// Java keywords:
terminal ABSTRACT,  CONTINUE,   FOR,          NEW,         SWITCH,
         ASSERT,    DEFAULT,    IF,           PACKAGE,     SYNCHRONIZED,
         BOOLEAN,   DO,         GOTO,         PRIVATE,     THIS,
         BREAK,     DOUBLE,     IMPLEMENTS,   PROTECTED,   THROW,
         BYTE,      ELSE,       IMPORT,       PUBLIC,      THROWS,
         CASE,      ENUM,       INSTANCEOF,   RETURN,      TRANSIENT,
         CATCH,     EXTENDS,    INT,          SHORT,       TRY,
         CHAR,      FINAL,      INTERFACE,    STATIC,      VOID,
         CLASS,     FINALLY,    LONG,         STRICTFP,    VOLATILE,
         CONST,     FLOAT,      NATIVE,       SUPER,       WHILE;

// additional keywords:
terminal MAIN, STRING, LENGTH, SYSTEM, OUT, PRINTLN;

// symbols:
terminal LBRACE, RBRACE, // { }
         LBRACKET, RBRACKET, // [ ]
         LPAREN, RPAREN, // ()
         DOT, SEMI, COMMA, EQ, NEG, AND, PLUS, MINUS, TIMES, DIV, LESS, EQUALS;

// literals:
terminal TRUE, FALSE, NULL;

//An identifier is a name, ID:name and ID:argName should be different
terminal String   NUMBER, ID;
   
// Non terminals used in the grammar section.  
non terminal MJProgram program;
non terminal MJMainClass mainclass;
non terminal MJClassDecl classdecl;

non terminal MJMemberDecl memberdecl;
non terminal MJMemberDeclList memberdecllist;
non terminal MJStatement statement;
non terminal MJBlock block;
non terminal MJVarDecl vardecl;
non terminal MJMethodDecl methodecl;
non terminal MJVarDeclList vardeclist;

non terminal MJExpr exp;


//Monireh
non terminal MJType type;

//Rama
non terminal MJOperator op;
non terminal MJExpr expr;
non terminal  MJExprList exprlist;

non terminal  MJExprList exprRest;



//non terminal MJBlock block;
//non terminal MJStatement statement;


non terminal  MJExpr exprest;
non terminal MJBlock block;
non terminal MJStatement statement;

//end rama
//Monireh

// a = b, b has high priority
// a = (x+5<10) and (8*y== 45)
precedence right EQ;
precedence left AND;
precedence left EQUALS;
precedence left LESS;
precedence left PLUS, MINUS;
precedence left TIMES, DIV;
// -3, 3 has the pirority
precedence right NEG;
precedence left DOT;
precedence left LPAREN;


/* ----------------------------Grammar Section-------------------- */


 program ::=
         mainclass:mc classdecl:cd
         {: RESULT = new MJProgram(mc, cd); :}
        ;
    // mc ::= is Wrong we have to use non terminal that we defined.
    // MainClass → class id { public static void main ( String [ ] id ) Block }
    mainclass ::=
        CLASS ID:name LBRACE PUBLIC STATIC VOID MAIN LPAREN
                            STRING LBRACKET RBRACKET ID:argName RPAREN block:body
                        RBRACE
        {:

            //id = new MJTypeClass(name);

            // RESULT = new MJMainClass(,body);   The Main-class cannot be instantiated
            RESULT = MJMainClass(name, argName ,body);
        :}
        ;

    // ClassDecl → class id { MemberDecl* }
    //   | class id extends id { MemberDecl* }
    //MemberDecl*  means might appear an arbitrary  number of times (MJClassDeclList)

    classdecl ::=
        CLASS ID:name LBRACE memberdecllist:mdl RBRACE
            {:
                RESULT = new MJClassDeclList(name,mdl);
            :}
        | CLASS ID EXTENDS ID:name LBRACE memberdecllist:mdl RBRACE
            {:
                RESULT = new MJClassDeclList(name, mdl);
            :}
        ;


    memberdecl ::= vardecl:vd

    {: RESULT=new MJMemberDecl(vd); :}
    |
    methodecl:mtd
    {: RESULT=new MJMemberDecl(mtd); :}
    ;

    vardecl ::= type:t ID:name SEMI
    {:
    RESULT = new MJVarDecl(t,name); :}
    ;

    methodecl::= type:t ID:name LBRACE vardeclist:vdl RBRACE block:b
    {:
    RESULT= new MJMethodDecl(t,name,vdl,b);:}
    ;

    vardeclist ::= type:t ID:name vardeclist:vdlrest
    {:
    RESULT =  new MJVarDeclList(t,name,vdlrest);:}
    ;

    vardeclist ::= COMMA type:t ID:name
    {:
    RESULT = new MJVarDeclList(t,name); :}
    ;
//Monireh start
 type ::=
        INT LBRACKET RBRACKET  {: RESULT = new MJTypeIntArray(); :}
        | BOOLEAN              {: RESULT = new MJTypeBool(); :}
        | INT                  {: RESULT = new MJTypeInt(); :}
        | ID:name              {: RESULT = new MJTypeClass(name); :};
//End of Type
//rama start


statement ::=

       block:body
       {: RESULT = new MJBlock(body); :}
       | IF LPAREN expr:e1 RPAREN statement:s1 ELSE statement:s2
        {: RESULT = new MJStmtIf(e1,s1,s2); :}
       | WHILE LPAREN expr:e1 RPAREN statement:s1
       {: RESULT = new MJStmtWhile(e1,s1); :}
       | RETURN   expr:e1
       {: RESULT = new MJStmtReturn(e1); :}
       |SYSTEM DOT OUT DOT PRINTLN  LPAREN expr :e1 RPAREN
       {: RESULT = new MJStmtPrint(e1); :}
       | expr:e1 SEMI
       {: RESULT = new MJStmtExpr(e1); :}
       | expr:e1 EQ expr:e2
       {: RESULT = new MJStmtAssign(e1,e2); :}


expr ::=       expr:e1 op:op1 expr:e2
			   {: RESULT = new MJOperator(e1,e2,op1); :}
			   |NEG expr:e1
			   {: RESULT = newMJNegate(e1); :}
			   | MINUS  expr:e1
               {: RESULT = new MJUnaryMinus(e1); :}
			   | expr:e1  LBRACKET expr:e2 RBRACKET
			   {: RESULT = new MJArrayLookup(e1,e2); :}
               | expr:e1  DOT LENGTH
                {: RESULT = new MJArrayLength(e1); :}
               | expr:e1  DOT ID:id
               {: RESULT = new MJFieldAccess(e1,id); :}
               | expr:e1  DOT ID:id LPAREN exprlist:el RPAREN
               {: RESULT = new MJMethodCall(e1,id,el); :}
			   |TRUE
			   {: RESULT = new MJTypeBool(); :}
			   | FALSE
			   {: RESULT = new MJTypeBool(); :}
			   | ID:id
			   {: RESULT = new MJVarDecl(id);  :}
			   | NUMBER:n
                {: RESULT = new MJNumber(Integer.parseInt(n)); : }
			   | THIS:t
			   {: RESULT = new MJExprThis(); :}
			   | NULL:n
               {: RESULT = new MJExprNull(); :}
               | NEW INT LBRACKET expr:e1 RBRACKET
			   {: RESULT = new MJNewIntArray(e1); :}

			   | NEW ID:id LPAREN RPAREN
               {: RESULT = new MJNewObject(id); :}
               |  LPAREN expr:e1 RPAREN
               {: RESULT = new  MJExpr(e1); :}
               ;

//exprlist ::=    expr:e1 ExpRest:er
 //              {: RESULT = new MJExprList(e1,er); :}
 //;
exprRest ::= expr:e1
exprRest ::=  COMMA  expr:e1
           {: RESULT = e1; :}
           ;


			   | NEW ID :id LPAREN RPAREN

               {: RESULT = new MJNewObject(id); :}

               |  LPAREN expr: e1 RPAREN
               {: RESULT = new  MJExpr(e1); :}
               ;
exprlist ::=    expr:e1 exprest:er
              {: RESULT = new MJExprList(e1,er); :}
 ;

exprest ::=  COMMA  expr: e1
              {: RESULT = new MJExprList(e1); :};

//ID ::=
           //  ???;
op::=
          AND {: RESULT = MJAnd(); :}
          | PLUS {: RESULT = MJPlus(); :}
           | MINUS {: RESULT = MJMinus(); :}
           | TIMES {: RESULT = MJTimes(); :}
           | DIV {: RESULT = MJDiv(); :}
           | LESS {: RESULT = MJLess(); :}
           | EQUALS {: RESULT = MJEquals(); :}
;


//end rama






















